name: Update NBA Minutes JSON (Basketball-Reference)

on:
  schedule:
    - cron: "0 10 * * *"   # daily at 10:00 UTC
  workflow_dispatch:        # run manually from Actions tab

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Prepare output folder
        run: |
          mkdir -p docs/minutes
          touch docs/.nojekyll

      - name: Install deps
        run: npm i cheerio@1

      - name: Generate NBA Minutes JSON (balldontlie -> Basketball-Reference fallback)
        run: |
          node - <<'NODE'
          import fs from 'node:fs/promises';
          import cheerio from 'cheerio';

          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          const todayKey = ()=>{
            const d=new Date();
            return d.toISOString().slice(0,10).replace(/-/g,'');
          };
          const seasonEndYear = ()=>{
            const d=new Date();
            return (d.getMonth()>=9)? d.getFullYear()+1 : d.getFullYear();
          };

          async function fetchJSON(url) {
            const res = await fetch(url, { headers: { 'User-Agent': 'minutes-bot/1.0' }});
            if (!res.ok) throw new Error(`GET ${url} -> ${res.status}`);
            return await res.json();
          }

          // ---------- TRY 1: balldontlie (fast path, may be unavailable early in season) ----------
          async function tryBalldontlie(startYear, endYear) {
            try {
              // 1) gather active players (paginated)
              let page = 1;
              const names = new Map();
              const teams = new Map();
              const ids = [];
              while (true) {
                const u = `https://www.balldontlie.io/api/v1/players?per_page=100&page=${page}&active=true`;
                const r = await fetch(u);
                if (r.status === 404) throw new Error('players endpoint 404');
                if (!r.ok) throw new Error(`players page ${page} -> ${r.status}`);
                const j = await r.json();
                (j.data ?? []).forEach(p=>{
                  ids.push(p.id);
                  names.set(p.id, `${p.first_name} ${p.last_name}`);
                  teams.set(p.id, p.team?.abbreviation ?? '‚Äî');
                });
                if (!j.meta?.next_page) break;
                page++;
                await sleep(150);
              }

              // 2) season averages in chunks of 100
              const chunk = (arr,n)=>arr.reduce((a,x,i)=>(i%n?a[a.length-1].push(x):a.push([x]),a),[]);
              const rows = [];
              let tmpId = 1;

              for (const ch of chunk(ids, 100)) {
                const url = new URL('https://www.balldontlie.io/api/v1/season_averages');
                url.searchParams.set('season', String(startYear));
                ch.forEach(id=>url.searchParams.append('player_ids[]', String(id)));
                const j = await fetchJSON(url.toString());
                for (const a of (j.data ?? [])) {
                  const min = a.min ?? '0:00';
                  const [mm, ss='0'] = min.split(':');
                  const mpg = Number(mm) + Number(ss)/60;
                  if (mpg<=0) continue;
                  rows.push({
                    id: tmpId++,
                    playerName: names.get(a.player_id) ?? String(a.player_id),
                    teamAbbr: teams.get(a.player_id) ?? '‚Äî',
                    games: a.games_played ?? 0,
                    mpg,
                    rawMin: min
                  });
                }
                await sleep(150);
              }

              rows.sort((a,b)=>b.mpg-a.mpg);
              if (!rows.length) return null;

              return {
                seasonEndYear: endYear,
                yyyymmdd: todayKey(),
                rows
              };
            } catch (e) {
              console.warn('balldontlie failed:', e.message);
              return null;
            }
          }

          // ---------- TRY 2: Basketball-Reference (HTML parse, very reliable) ----------
          async function fromBBRef(endYear) {
            const url = `https://www.basketball-reference.com/leagues/NBA_${endYear}_per_game.html`;
            const res = await fetch(url, { headers: { 'User-Agent': 'minutes-bot/1.0' }});
            if (!res.ok) throw new Error(`BBRef ${endYear} -> ${res.status}`);
            const html = await res.text();

            const $ = cheerio.load(html);
            const seen = new Map(); // key: player name, value: row; prefer TOT
            $('#per_game_stats tbody tr').each((_, el) => {
              const row = $(el);
              if (row.hasClass('thead')) return;

              const name = row.find('[data-stat="player"]').text().trim();
              const team = (row.find('[data-stat="team_id"]').text().trim() || '‚Äî');
              const gStr = row.find('[data-stat="g"]').text().trim() || '0';
              const mpStr = row.find('[data-stat="mp_per_g"]').text().trim() || '0';
              const gp = parseInt(gStr, 10);
              const mpg = parseFloat(mpStr);

              if (!name || !Number.isFinite(mpg) || mpg<=0) return;

              const cand = {
                id: 0, playerName: name, teamAbbr: team,
                games: Number.isFinite(gp)? gp : 0,
                mpg, rawMin: mpg.toFixed(1)
              };

              const existed = seen.get(name);
              if (!existed) seen.set(name, cand);
              else if (team === 'TOT') seen.set(name, cand); // prefer TOT
            });

            const rows = Array.from(seen.values())
              .map((r, idx) => ({ ...r, id: idx+1 }))
              .sort((a,b)=>b.mpg-a.mpg);

            if (!rows.length) throw new Error('BBRef parse produced 0 rows');

            return {
              seasonEndYear: endYear,
              yyyymmdd: todayKey(),
              rows
            };
          }

          // ---------------- MAIN ----------------
          const endYear = seasonEndYear();
          const startYear = endYear - 1;
          const outPath = `docs/minutes/${endYear}.json`;

          console.log(`üéØ Target season: ${startYear}-${String(endYear).slice(2)}`);

          // wrap everything in an async IIFE so we can safely use await (no top-level return!)
          (async () => {
            // 1) Try balldontlie for current season
            let env = await tryBalldontlie(startYear, endYear);

            // 2) If no luck, try BBRef for endYear, then fallback to previous endYear-1
            if (!env) {
              try {
                env = await fromBBRef(endYear);
              } catch (e1) {
                console.warn('BBRef current season failed, trying previous:', e1.message);
                env = await fromBBRef(endYear - 1);
              }
            }

            // write the envelope
            await fs.writeFile(outPath, JSON.stringify(env, null, 2));
            console.log(`‚úÖ Saved ${outPath} (${env.rows.length} players)`);
          })().catch(err => {
            console.error('‚ùå Script failed:', err);
            process.exit(1);
          });
          NODE

      - name: Commit and push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs/minutes/*.json docs/.nojekyll
          git commit -m "Auto-update NBA minutes JSON" || echo "No changes"
          git push
